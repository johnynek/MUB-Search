{-
  Clique Finding
  2009 Nathan Blythe, Dr. Oscar Boykin (see LICENSE for details)

  Find cliques on a special graph, defined by the following features:
    - Vertices that can be "expanded" and "contracted" to lists of the same
      type as vertices themselves.

    - The vertices adjacent to the 0 vertex are sufficient to describe all
      edges on the graph.

    - The neighbors to a particular vertex can be generated by expanding the
      vertex and contracting its pointwise quotient with the (expanded)
      0-adjacent vertices.

  Vertex types are defined for Integers (scalars) and lists of Integers
  (vectors).

  Note: the "Flexible Instances" Haskell extensions is required.  In GHC/GHCI
  this necessitates the -XFlexibleInstances flag.
-}

import System(getArgs)
import Data.List

import Magic


{-
  Type class for types that can be vertices on a graph.

  int: intersection between two lists of vertices
  e:   expand a list of vertices
  x:   pointwise quotient of two lists of vertices
  c:   contract a list of vertices
-}
class (Eq a, Ord a) => V a where
  int :: [a] -> [a] -> [a]
  e   :: Integer -> Integer -> a -> [a]
  x   :: Integer -> Integer -> [a] -> [a] -> [a]
  c   :: Integer -> Integer -> [a] -> a


{-
  Integers are a valid vertex type.
-}
instance V Integer where
  int l1 l2   = intersect l1 l2
  e d n x     = magic2vec (d, n) x
  x _ n l1 l2 = zipWith (\x y -> mod (x - y) n) l1 l2
  c d n l     = vec2magic (d, n) l


{-
  Lists of Integers are a valid vertex type.
-}
instance (V [Integer]) where
  int l1 l2   = intersect (sort l1) (sort l2)
  e d n x     = magics2vecs (d, n) x
  x _ n l1 l2 = zipWith (zipWith (\x y -> mod (x - y) n)) l1 l2
  c d n l     = vecs2magics (d, n) l


{-
  The intersection of all lists in a list, performed pairwise repeatedly.
-}
ints :: (V a) => [[a]] -> [a]
ints []          = []
ints (h : [])    = h
ints (h : g : t) = ints ((int h g) : t)


{-
  All size k super cliques of a clique q, given a list l of potential
  extending vertices.
-}
cliques' :: (V a) => Integer -> Integer -> Integer -> [a] -> ([a], [a]) -> [[a]]
cliques' _ _ 0 l (q, _) = [q]
cliques' d n k l (q, r) = concatMap (cliques' d n (k - 1) l) s
                      where s = map (\ v -> (v : q, int r (nbrs d n l v))) r


{-
  All size k cliques that include a clique from list qs.
-}
cliques :: (V a) => Integer -> Integer -> Integer -> [a] -> [[a]] -> [[a]]
cliques d n k l qs = concatMap (\ q -> cliques' d n (k' q) l (g q)) qs
                     where g  q = (q, ints (map (nbrs d n l) q))
                           k' q = k - (toInteger . length) q


{-
  Neighbors to a vertex.
-}
nbrs :: C a => Integer -> Integer -> [a] -> a -> [a]
nbrs d n []      _ = []
nbrs d n (h : t) v = if    h' > v
                     then  h' : t'
                     else  t'
                     where h' = c d n (x d n (e d n v) (e d n h))
                           t' = nbrs d n t v


{-
  Permutation-free list, given a function to compute a permutation-invariant of
  an object.
-}
permfree :: (Eq b) => (a -> b) -> [a] -> [a]
permfree f l = g [] l
               where g _ [] = []
                     g sl (h : t) = if   all (/= h') sl
                                    then h : g (h' : sl) t
                                    else g sl t
                                    where h' = f h


{-
  Determine how much work this particular process will do, and form the
  starts of the cliques that it will extend.
-}
specJobs :: Integer -> Integer -> [a] -> [a] -> [[a]]
specJobs s p z l | s <= 0               = [x : z | x <- l]
                 | (s < 0) || (s > nJ)  = error ("Job size out of range (" ++ (show nJ) ++ " jobs total)")
                 | (p < 0) || (p >= nP) = error ("Process index out of range (" ++ (show nP) ++ " processes total)")
                 | otherwise            = map (\x -> (genericIndex l x) : z) [p * s .. min ((p + 1) * s - 1) (nJ - 1)]
                   where nJ = toInteger (length l)
                         nP = (div nJ s) + (if mod nJ s == 0 then 0 else 1)


{-
  Cliques <d> <n> <fAdj> <r> <fTen> <k> <s> <p>

  Dimension d.
  nth roots of unity.
  Vectors adjacent to the 0-vector read from fAdj.
  Vertices are scalers (r = 1) or vectors (r = 2).
  Generating set (under permutations) of vertices read from fTen.
  Search for k-cliques.
  This process performs jobs p * s through (p + 1) * s - 1.
  If s == 0, the entire search is performed.
-}
main = do
  {-
    Command line arguments.
  -}
  d' : (n' : (fAdj : (r' : (fTen : (k' : (s' : (p' : argsT))))))) <- getArgs
  let d = read d' :: Integer
  let n = read n' :: Integer
  let r = read r' :: Integer
  let k = read k' :: Integer
  let s = read s' :: Integer
  let p = read p' :: Integer


  {-
    Common.
  -}
  ns' <- readFile fAdj
  vs' <- readFile fTen


  {-
    r = 1.
  -}
  let q1 = cliques d n k ns (specJobs s p [0] vs)
           where ns = map read (lines ns') :: [Integer]
                 vs = permfree (sort . magic2vec (d, n)) $ map read (lines vs') :: [Integer]


  {-
    r = 2.
  -}
  let q2 = cliques d n k ns (specJobs s p [] vs)
           where ns = map ((genericTake d) . repeat . read) (lines ns') :: [[Integer]]
                 vs = permfree (transpose . sort . transpose . magics2vecs (d, n)) $ map read (lines vs') :: [[Integer]]


  {-
    Output.
  -}
  let s | k <= 2 = error ((show k) ++ "-cliques are boring")
        | r == 1 = map (putStrLn . show) q1
        | r == 2 = map (putStrLn . show) q2
  sequence_ $ s

